; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	c:\Documents and Settings\SudaNix\Desktop\eqraOS\eqraOS-doc\examples\ch4\keyboard_driver\core\kernel\vmm.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?_cur_page_dir@@3PAUpage_dir_table@@A		; _cur_page_dir
PUBLIC	?_cur_page_dir_base_register@@3IA		; _cur_page_dir_base_register
_BSS	SEGMENT
?_cur_page_dir@@3PAUpage_dir_table@@A DD 01H DUP (?)	; _cur_page_dir
?_cur_page_dir_base_register@@3IA DD 01H DUP (?)	; _cur_page_dir_base_register
_BSS	ENDS
PUBLIC	?vmm_alloc_page@@YA_NPAI@Z			; vmm_alloc_page
EXTRN	?pte_add_attrib@@YAXPAII@Z:PROC			; pte_add_attrib
EXTRN	?pte_set_frame@@YAXPAII@Z:PROC			; pte_set_frame
EXTRN	?pmm_alloc@@YAPAXXZ:PROC			; pmm_alloc
; Function compile flags: /Ogtpy
; File c:\documents and settings\sudanix\desktop\eqraos\eqraos-doc\examples\ch4\keyboard_driver\core\kernel\vmm.cpp
_TEXT	SEGMENT
_e$ = 8							; size = 4
?vmm_alloc_page@@YA_NPAI@Z PROC				; vmm_alloc_page

; 48   : 	void* p = pmm_alloc();

	call	?pmm_alloc@@YAPAXXZ			; pmm_alloc

; 49   : 	if (!p)

	test	eax, eax
	jne	SHORT $LN1@vmm_alloc_

; 50   : 		return false;

	xor	al, al

; 56   : }

	ret	0
$LN1@vmm_alloc_:
	push	esi

; 51   : 	
; 52   : 	pte_set_frame(e,(uint32_t)p);

	mov	esi, DWORD PTR _e$[esp]
	push	eax
	push	esi
	call	?pte_set_frame@@YAXPAII@Z		; pte_set_frame

; 53   : 	pte_add_attrib(e,I386_PTE_PRESENT);

	push	1
	push	esi
	call	?pte_add_attrib@@YAXPAII@Z		; pte_add_attrib
	add	esp, 16					; 00000010H

; 54   : 	
; 55   : 	return true;

	mov	al, 1
	pop	esi

; 56   : }

	ret	0
?vmm_alloc_page@@YA_NPAI@Z ENDP				; vmm_alloc_page
_TEXT	ENDS
PUBLIC	?vmm_free_page@@YAXPAI@Z			; vmm_free_page
EXTRN	?pte_del_attrib@@YAXPAII@Z:PROC			; pte_del_attrib
EXTRN	?pmm_dealloc@@YAXPAX@Z:PROC			; pmm_dealloc
EXTRN	?pte_get_frame@@YAII@Z:PROC			; pte_get_frame
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_e$ = 8							; size = 4
?vmm_free_page@@YAXPAI@Z PROC				; vmm_free_page

; 58   : void vmm_free_page(uint32_t* e) {

	push	esi

; 59   : 	void* p = (void*)pte_get_frame(*e);

	mov	esi, DWORD PTR _e$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	?pte_get_frame@@YAII@Z			; pte_get_frame
	add	esp, 4

; 60   : 	
; 61   : 	if (p)

	test	eax, eax
	je	SHORT $LN1@vmm_free_p

; 62   : 		pmm_dealloc(p);

	push	eax
	call	?pmm_dealloc@@YAXPAX@Z			; pmm_dealloc
	add	esp, 4
$LN1@vmm_free_p:

; 63   : 		
; 64   : 	pte_del_attrib(e,I386_PTE_PRESENT);

	push	1
	push	esi
	call	?pte_del_attrib@@YAXPAII@Z		; pte_del_attrib
	add	esp, 8
	pop	esi

; 65   : 	
; 66   : }

	ret	0
?vmm_free_page@@YAXPAI@Z ENDP				; vmm_free_page
_TEXT	ENDS
PUBLIC	?vmm_switch_page_dir_table@@YA_NPAUpage_dir_table@@@Z ; vmm_switch_page_dir_table
EXTRN	?pmm_load_PDBR@@YAXI@Z:PROC			; pmm_load_PDBR
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_pd$ = 8						; size = 4
?vmm_switch_page_dir_table@@YA_NPAUpage_dir_table@@@Z PROC ; vmm_switch_page_dir_table

; 70   : 	if (!pd)

	mov	eax, DWORD PTR _pd$[esp-4]
	test	eax, eax
	jne	SHORT $LN1@vmm_switch

; 71   : 		return false;

	xor	al, al

; 76   : }

	ret	0
$LN1@vmm_switch:

; 72   : 	
; 73   : 	_cur_page_dir = pd;

	mov	DWORD PTR ?_cur_page_dir@@3PAUpage_dir_table@@A, eax ; _cur_page_dir

; 74   : 	pmm_load_PDBR(_cur_page_dir_base_register);

	mov	eax, DWORD PTR ?_cur_page_dir_base_register@@3IA ; _cur_page_dir_base_register
	push	eax
	call	?pmm_load_PDBR@@YAXI@Z			; pmm_load_PDBR
	add	esp, 4

; 75   : 	return true;

	mov	al, 1

; 76   : }

	ret	0
?vmm_switch_page_dir_table@@YA_NPAUpage_dir_table@@@Z ENDP ; vmm_switch_page_dir_table
_TEXT	ENDS
PUBLIC	?vmm_get_page_dir_table@@YAPAUpage_dir_table@@XZ ; vmm_get_page_dir_table
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?vmm_get_page_dir_table@@YAPAUpage_dir_table@@XZ PROC	; vmm_get_page_dir_table

; 79   : 	return _cur_page_dir;

	mov	eax, DWORD PTR ?_cur_page_dir@@3PAUpage_dir_table@@A ; _cur_page_dir

; 80   : }

	ret	0
?vmm_get_page_dir_table@@YAPAUpage_dir_table@@XZ ENDP	; vmm_get_page_dir_table
_TEXT	ENDS
PUBLIC	?vmm_flush_tlb_entry@@YAXI@Z			; vmm_flush_tlb_entry
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_addr$ = 8						; size = 4
?vmm_flush_tlb_entry@@YAXI@Z PROC			; vmm_flush_tlb_entry

; 83   : #ifdef _MSC_VER
; 84   : 	_asm {
; 85   : 		cli

	cli

; 86   : 		invlpg addr

	invlpg	DWORD PTR _addr$[esp-4]

; 87   : 		sti

	sti

; 88   : 	}
; 89   : #endif
; 90   : }

	ret	0
?vmm_flush_tlb_entry@@YAXI@Z ENDP			; vmm_flush_tlb_entry
_TEXT	ENDS
PUBLIC	?vmm_page_table_clear@@YAXPAUpage_table@@@Z	; vmm_page_table_clear
EXTRN	?memset@@YAPAXPAXDI@Z:PROC			; memset
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_pt$ = 8						; size = 4
?vmm_page_table_clear@@YAXPAUpage_table@@@Z PROC	; vmm_page_table_clear

; 93   : 	if (pt)

	mov	eax, DWORD PTR _pt$[esp-4]
	test	eax, eax
	je	SHORT $LN1@vmm_page_t

; 94   : 		memset(pt,0,sizeof(page_table));

	push	4096					; 00001000H
	push	0
	push	eax
	call	?memset@@YAPAXPAXDI@Z			; memset
	add	esp, 12					; 0000000cH
$LN1@vmm_page_t:

; 95   : }

	ret	0
?vmm_page_table_clear@@YAXPAUpage_table@@@Z ENDP	; vmm_page_table_clear
_TEXT	ENDS
PUBLIC	?vmm_vir_to_page_table_index@@YAII@Z		; vmm_vir_to_page_table_index
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_addr$ = 8						; size = 4
?vmm_vir_to_page_table_index@@YAII@Z PROC		; vmm_vir_to_page_table_index

; 98   : 	if ( addr  >= PT_ADDRESS_SPACE_SIZE )

	mov	eax, DWORD PTR _addr$[esp-4]
	cmp	eax, 4194304				; 00400000H
	jb	SHORT $LN2@vmm_vir_to

; 99   : 		return 0;

	xor	eax, eax

; 102  : }

	ret	0
$LN2@vmm_vir_to:

; 100  : 	else
; 101  : 		return addr / PAGE_SIZE;

	shr	eax, 12					; 0000000cH

; 102  : }

	ret	0
?vmm_vir_to_page_table_index@@YAII@Z ENDP		; vmm_vir_to_page_table_index
_TEXT	ENDS
PUBLIC	?vmm_page_table_lookup_entry@@YAPAIPAUpage_table@@I@Z ; vmm_page_table_lookup_entry
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_pt$ = 8						; size = 4
_addr$ = 12						; size = 4
?vmm_page_table_lookup_entry@@YAPAIPAUpage_table@@I@Z PROC ; vmm_page_table_lookup_entry

; 105  : 	if (pt)

	mov	ecx, DWORD PTR _pt$[esp-4]
	test	ecx, ecx
	je	SHORT $LN2@vmm_page_t@2

; 106  : 		return &pt->pte[vmm_vir_to_page_table_index(addr)];

	mov	eax, DWORD PTR _addr$[esp-4]
	cmp	eax, 4194304				; 00400000H
	jb	SHORT $LN6@vmm_page_t@2
	xor	eax, eax
	lea	eax, DWORD PTR [ecx+eax*4]

; 109  : }

	ret	0

; 106  : 		return &pt->pte[vmm_vir_to_page_table_index(addr)];

$LN6@vmm_page_t@2:
	shr	eax, 12					; 0000000cH
	lea	eax, DWORD PTR [ecx+eax*4]

; 109  : }

	ret	0
$LN2@vmm_page_t@2:

; 107  : 	else
; 108  : 		return 0;

	xor	eax, eax

; 109  : }

	ret	0
?vmm_page_table_lookup_entry@@YAPAIPAUpage_table@@I@Z ENDP ; vmm_page_table_lookup_entry
_TEXT	ENDS
PUBLIC	?vmm_vir_to_page_dir_table_index@@YAII@Z	; vmm_vir_to_page_dir_table_index
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_addr$ = 8						; size = 4
?vmm_vir_to_page_dir_table_index@@YAII@Z PROC		; vmm_vir_to_page_dir_table_index

; 112  : 	if ( addr >= PD_ADDRESS_SPACE_SIZE )

	mov	eax, DWORD PTR _addr$[esp-4]
	xor	ecx, ecx
	cmp	ecx, 1
	jl	SHORT $LN2@vmm_vir_to@2
	jg	SHORT $LN5@vmm_vir_to@2
	test	eax, eax
	jb	SHORT $LN2@vmm_vir_to@2
$LN5@vmm_vir_to@2:

; 113  : 		return 0;

	xor	eax, eax

; 116  : }

	ret	0
$LN2@vmm_vir_to@2:

; 114  : 	else
; 115  : 		return addr / PAGE_SIZE;

	shr	eax, 12					; 0000000cH

; 116  : }

	ret	0
?vmm_vir_to_page_dir_table_index@@YAII@Z ENDP		; vmm_vir_to_page_dir_table_index
_TEXT	ENDS
PUBLIC	?vmm_page_dir_table_clear@@YAXPAUpage_dir_table@@@Z ; vmm_page_dir_table_clear
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_pd$ = 8						; size = 4
?vmm_page_dir_table_clear@@YAXPAUpage_dir_table@@@Z PROC ; vmm_page_dir_table_clear

; 119  : 	if (pd)

	mov	eax, DWORD PTR _pd$[esp-4]
	test	eax, eax
	je	SHORT $LN1@vmm_page_d

; 120  : 		memset(pd,0,sizeof(page_dir_table));

	push	4096					; 00001000H
	push	0
	push	eax
	call	?memset@@YAPAXPAXDI@Z			; memset
	add	esp, 12					; 0000000cH
$LN1@vmm_page_d:

; 121  : }

	ret	0
?vmm_page_dir_table_clear@@YAXPAUpage_dir_table@@@Z ENDP ; vmm_page_dir_table_clear
_TEXT	ENDS
PUBLIC	?vmm_page_dir_table_lookup_entry@@YAPAIPAUpage_dir_table@@I@Z ; vmm_page_dir_table_lookup_entry
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_pd$ = 8						; size = 4
_addr$ = 12						; size = 4
?vmm_page_dir_table_lookup_entry@@YAPAIPAUpage_dir_table@@I@Z PROC ; vmm_page_dir_table_lookup_entry

; 124  : 	if (pd)

	mov	ecx, DWORD PTR _pd$[esp-4]
	test	ecx, ecx
	je	SHORT $LN2@vmm_page_d@2

; 125  : 		return &pd->pde[vmm_vir_to_page_table_index(addr)];

	mov	eax, DWORD PTR _addr$[esp-4]
	cmp	eax, 4194304				; 00400000H
	jb	SHORT $LN6@vmm_page_d@2
	xor	eax, eax
	lea	eax, DWORD PTR [ecx+eax*4]

; 128  : }

	ret	0

; 125  : 		return &pd->pde[vmm_vir_to_page_table_index(addr)];

$LN6@vmm_page_d@2:
	shr	eax, 12					; 0000000cH
	lea	eax, DWORD PTR [ecx+eax*4]

; 128  : }

	ret	0
$LN2@vmm_page_d@2:

; 126  : 	else 
; 127  : 		return 0;

	xor	eax, eax

; 128  : }

	ret	0
?vmm_page_dir_table_lookup_entry@@YAPAIPAUpage_dir_table@@I@Z ENDP ; vmm_page_dir_table_lookup_entry
_TEXT	ENDS
PUBLIC	?vmm_init@@YAXXZ				; vmm_init
EXTRN	?pmm_enable_paging@@YAX_N@Z:PROC		; pmm_enable_paging
EXTRN	?pde_set_frame@@YAXPAII@Z:PROC			; pde_set_frame
EXTRN	?pde_add_attrib@@YAXPAII@Z:PROC			; pde_add_attrib
EXTRN	?pmm_allocs@@YAPAXI@Z:PROC			; pmm_allocs
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_page$2703 = -4						; size = 4
?vmm_init@@YAXXZ PROC					; vmm_init

; 14   : void vmm_init() {

	push	ecx
	push	edi

; 15   : 	page_table* pt = (page_table*) pmm_alloc();

	call	?pmm_alloc@@YAPAXXZ			; pmm_alloc
	mov	edi, eax

; 16   : 	if (!pt)

	test	edi, edi
	je	$LN6@vmm_init
	push	ebx
	push	esi

; 17   : 		return ;
; 18   : 	
; 19   : 	vmm_page_table_clear(pt);

	push	4096					; 00001000H
	push	0
	push	edi
	call	?memset@@YAPAXPAXDI@Z			; memset
	add	esp, 12					; 0000000cH

; 20   : 	
; 21   : 	for (int i=0, frame =0; i < 1024 ; ++i, frame += 4096) {

	xor	esi, esi
	mov	ebx, 1024				; 00000400H
	npad	6
$LL4@vmm_init:

; 22   : 		uint32_t page = 0;
; 23   : 		pte_add_attrib(&page,I386_PTE_PRESENT);

	lea	eax, DWORD PTR _page$2703[esp+16]
	push	1
	push	eax
	mov	DWORD PTR _page$2703[esp+24], 0
	call	?pte_add_attrib@@YAXPAII@Z		; pte_add_attrib

; 24   : 		pte_set_frame(&page,frame);

	lea	ecx, DWORD PTR _page$2703[esp+24]
	push	esi
	push	ecx
	call	?pte_set_frame@@YAXPAII@Z		; pte_set_frame
	add	esp, 16					; 00000010H

; 25   : 		
; 26   : 		pt->pte[vmm_vir_to_page_table_index(frame)] = page;

	cmp	esi, 4194304				; 00400000H
	jb	SHORT $LN12@vmm_init
	xor	eax, eax
	jmp	SHORT $LN11@vmm_init
$LN12@vmm_init:
	mov	eax, esi
	shr	eax, 12					; 0000000cH
$LN11@vmm_init:
	mov	edx, DWORD PTR _page$2703[esp+16]
	add	esi, 4096				; 00001000H
	sub	ebx, 1
	mov	DWORD PTR [edi+eax*4], edx
	jne	SHORT $LL4@vmm_init

; 27   : 	}
; 28   : 	
; 29   : 	page_dir_table* pd = (page_dir_table*) pmm_allocs(3);

	push	3
	call	?pmm_allocs@@YAPAXI@Z			; pmm_allocs
	mov	esi, eax
	add	esp, 4

; 30   : 	if (!pd)

	test	esi, esi
	je	SHORT $LN33@vmm_init

; 31   : 		return ;
; 32   : 		
; 33   : 	vmm_page_dir_table_clear(pd);

	push	4096					; 00001000H
	push	0
	push	esi
	call	?memset@@YAPAXPAXDI@Z			; memset

; 34   : 	
; 35   : 	uint32_t* pde = vmm_page_dir_table_lookup_entry(pd,0);
; 36   : 	pde_add_attrib(pde,I386_PDE_PRESENT);

	push	1
	push	esi
	call	?pde_add_attrib@@YAXPAII@Z		; pde_add_attrib

; 37   : 	pde_add_attrib(pde,I386_PDE_WRITABLE);

	push	2
	push	esi
	call	?pde_add_attrib@@YAXPAII@Z		; pde_add_attrib

; 38   : 	pde_set_frame(pde,(uint32_t)pt);

	push	edi
	push	esi
	call	?pde_set_frame@@YAXPAII@Z		; pde_set_frame

; 39   : 	
; 40   : 	_cur_page_dir_base_register = (uint32_t) &pd->pde;
; 41   : 	vmm_switch_page_dir_table(pd);

	push	esi
	mov	DWORD PTR ?_cur_page_dir_base_register@@3IA, esi ; _cur_page_dir_base_register
	mov	DWORD PTR ?_cur_page_dir@@3PAUpage_dir_table@@A, esi ; _cur_page_dir
	call	?pmm_load_PDBR@@YAXI@Z			; pmm_load_PDBR

; 42   : 	
; 43   : 	pmm_enable_paging(true);

	push	1
	call	?pmm_enable_paging@@YAX_N@Z		; pmm_enable_paging
	add	esp, 44					; 0000002cH
$LN33@vmm_init:
	pop	esi
	pop	ebx
$LN6@vmm_init:
	pop	edi

; 44   : 	
; 45   : }

	pop	ecx
	ret	0
?vmm_init@@YAXXZ ENDP					; vmm_init
_TEXT	ENDS
END
